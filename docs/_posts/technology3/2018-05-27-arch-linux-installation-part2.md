---
tags:
- name: ... os
  score: 3.8
- name: 1000x smarter
  score: 4.0
- name: able
  score: 1.0
- name: accompanied
  score: 1.0
- name: actually benefit
  score: 4.0
- name: allowed
  score: 1.0
- name: allows
  score: 1.0
- name: already
  score: 1.0
- name: approach
  score: 1.0
- name: arch
  score: 1.5
- name: article
  score: 1.0
- name: articles
  score: 1.0
- name: ask
  score: 1.0
- name: assumes
  score: 1.0
- name: atomic builds
  score: 3.5
- name: battling
  score: 1.0
- name: becomes
  score: 1.0
- name: best thing
  score: 4.0
- name: binary
  score: 1.0
- name: blog
  score: 1.5
- name: blog uses
  score: 3.0
- name: branches
  score: 1.0
- name: build
  score: 1.5
- name: build using
  score: 3.0
- name: building
  score: 1.0
- name: builds
  score: 1.5
- name: change
  score: 1.0
- name: ci
  score: 1.75
- name: ci job
  score: 3.75
- name: code
  score: 1.5
- name: code working
  score: 3.5
- name: collision
  score: 1.0
- name: commit
  score: 1.0
- name: compared
  score: 1.0
- name: compile
  score: 1.0
- name: compiled files
  score: 3.5
- name: complete
  score: 1.0
- name: concern
  score: 1.0
- name: config file
  score: 4.0
- name: configuration script
  score: 3.666666666666667
- name: configure something
  score: 3.5
- name: couple
  score: 1.0
- name: curl directly
  score: 4.0
- name: day
  score: 1.0
- name: decided
  score: 1.0
- name: default
  score: 1.5
- name: default user
  score: 3.5
- name: dependencies
  score: 1.6666666666666667
- name: dependencies jekyll
  score: 3.666666666666667
- name: dependency
  score: 1.5
- name: dependency management
  score: 3.5
- name: deterministic
  score: 1.0
- name: different
  score: 1.6666666666666667
- name: different name
  score: 3.666666666666667
- name: directly curl
  score: 4.0
- name: dual boot
  score: 4.0
- name: e
  score: 1.0
- name: easy
  score: 1.0
- name: environment
  score: 1.0
- name: error messages
  score: 4.0
- name: even
  score: 1.5
- name: even starting
  score: 3.0
- name: every package
  score: 3.8
- name: exactly
  score: 1.0
- name: example
  score: 1.75
- name: excuses
  score: 1.0
- name: existing arch
  score: 3.5
- name: failure
  score: 1.0
- name: figure
  score: 1.0
- name: files
  score: 1.5
- name: fine
  score: 1.5
- name: fine example
  score: 3.25
- name: fix
  score: 1.0
- name: fixing
  score: 1.0
- name: former
  score: 1.0
- name: get
  score: 1.0
- name: getting
  score: 1.0
- name: github
  score: 1.6666666666666667
- name: github link
  score: 3.166666666666667
- name: github repository
  score: 3.666666666666667
- name: gitlab ci
  score: 3.75
- name: global state
  score: 4.0
- name: good example
  score: 3.75
- name: guessed
  score: 1.0
- name: happens
  score: 1.0
- name: hard
  score: 1.0
- name: heaviest yet
  score: 4.0
- name: hint look
  score: 4.0
- name: hosting
  score: 1.0
- name: ideoligies
  score: 1.0
- name: includes commits
  score: 4.0
- name: install
  score: 1.6666666666666667
- name: install nix
  score: 3.5
- name: installation
  score: 1.5
- name: installation procedure
  score: 3.5
- name: installed
  score: 1.0
- name: installing
  score: 1.0
- name: instead
  score: 1.0
- name: know
  score: 1.0
- name: language
  score: 1.0
- name: laptop
  score: 1.0
- name: last semester
  score: 4.0
- name: latter
  score: 1.0
- name: learnt enough
  score: 4.0
- name: libraries
  score: 1.0
- name: like
  score: 1.5
- name: lines
  score: 1.0
- name: link
  score: 1.5
- name: links
  score: 1.0
- name: longer
  score: 1.0
- name: lose track
  score: 4.0
- name: lot
  score: 1.5
- name: made
  score: 1.0
- name: major advantages
  score: 4.0
- name: make
  score: 1.0
- name: master branch
  score: 4.0
- name: means
  score: 1.0
- name: methodologies like
  score: 3.5
- name: modify
  score: 1.0
- name: mostly
  score: 1.0
- name: much
  score: 1.0
- name: need
  score: 1.0
- name: new dependencies
  score: 3.666666666666667
- name: next error
  score: 4.0
- name: nix
  score: 1.8333333333333333
- name: nix ci
  score: 3.583333333333333
- name: nix depending
  score: 3.833333333333333
- name: nix full
  score: 3.833333333333333
- name: nix store
  score: 3.833333333333333
- name: nixci example
  score: 3.75
- name: nixey goodness
  score: 4.0
- name: nixos
  score: 1.0
- name: non
  score: 1.0
- name: none
  score: 1.0
- name: note
  score: 1.0
- name: often discover
  score: 4.0
- name: one
  score: 1.0
- name: operating system
  score: 4.0
- name: operating systems
  score: 4.0
- name: opinion
  score: 1.0
- name: os
  score: 1.8
- name: os provides
  score: 3.8
- name: os running
  score: 3.8
- name: package
  score: 1.8
- name: package manager
  score: 3.8
- name: package would
  score: 3.8
- name: package written
  score: 3.466666666666667
- name: packages
  score: 1.5
- name: packages along
  score: 3.5
- name: passed
  score: 1.0
- name: pc
  score: 1.0
- name: point
  score: 1.0
- name: possible
  score: 1.0
- name: precisely lists
  score: 4.0
- name: problem
  score: 1.0
- name: program
  score: 1.0
- name: project
  score: 1.0
- name: pushed
  score: 1.0
- name: put
  score: 1.0
- name: quickly
  score: 1.0
- name: quite different
  score: 3.666666666666667
- name: ran
  score: 1.0
- name: rather lot
  score: 3.5
- name: read
  score: 1.0
- name: reading
  score: 1.0
- name: realised
  score: 1.0
- name: reason
  score: 1.0
- name: recently struggling
  score: 4.0
- name: reinstall
  score: 1.0
- name: reported
  score: 1.0
- name: repository directly
  score: 4.0
- name: required
  score: 1.0
- name: requirements emerge
  score: 4.0
- name: result
  score: 1.0
- name: right
  score: 1.0
- name: root
  score: 1.5
- name: root user
  score: 3.5
- name: run
  score: 1.5
- name: run tests
  score: 3.0
- name: running ubuntu
  score: 3.5
- name: runs
  score: 1.0
- name: runtime
  score: 1.0
- name: script
  score: 1.6666666666666667
- name: scripts
  score: 1.0
- name: search
  score: 1.0
- name: see
  score: 1.0
- name: set
  score: 1.0
- name: sh
  score: 1.6666666666666667
- name: sh creates
  score: 3.666666666666667
- name: sh script
  score: 3.3333333333333335
- name: shell
  score: 1.0
- name: simple matter
  score: 4.0
- name: simplifies development
  score: 4.0
- name: since
  score: 1.5
- name: single
  score: 1.0
- name: small bunch
  score: 4.0
- name: solution
  score: 1.0
- name: something
  score: 1.5
- name: sourcing
  score: 1.0
- name: starting
  score: 1.5
- name: static website
  score: 3.5
- name: sudo priviledges
  score: 4.0
- name: supposed
  score: 1.0
- name: switch
  score: 1.0
- name: switched
  score: 1.0
- name: take
  score: 1.0
- name: talk
  score: 1.0
- name: talking
  score: 1.0
- name: tests
  score: 1.5
- name: throwback
  score: 1.0
- name: thus
  score: 1.0
- name: time
  score: 1.0
- name: travis
  score: 1.5
- name: travis since
  score: 3.0
- name: travisci
  score: 1.0
- name: trouble
  score: 1.0
- name: try
  score: 1.0
- name: trying
  score: 1.0
- name: ubuntu
  score: 1.5
- name: upgrades
  score: 1.0
- name: upload
  score: 1.0
- name: usage
  score: 1.0
- name: use
  score: 1.0
- name: used
  score: 1.0
- name: useful
  score: 1.0
- name: user running
  score: 4.0
- name: uses
  score: 1.5
- name: using
  score: 1.5
- name: usr bin
  score: 4.0
- name: view
  score: 1.0
- name: virtualenv except
  score: 4.0
- name: website
  score: 1.5
- name: well
  score: 1.0
- name: whole os
  score: 3.8
- name: workings
  score: 1.0
- name: wrapper around
  score: 4.0
- name: wrapper install
  score: 3.666666666666667
- name: write
  score: 1.0
- name: writing
  score: 1.0
- name: written
  score: 1.6666666666666667
- name: written anything
  score: 3.666666666666667
- name: year ago
  score: 4.0
- name: yes
  score: 1.0
- name: yml file
  score: 4.0
layout: post
title: Installation of Arch part2 aka post installation
meta: Here I will be sharing stuff you need to take care of after instlling the sexy Arch OS in your computer.
category: Technology
---
So, I know I haven't written anything in a while, and that's because the last semester was my heaviest yet. But now since that has passed, I no longer have excuses to not write more articles. So go ahead, read on.

Before starting this article, if you do not know about Nix/NixOS, first go and read up about it: NixOS. NixOS in my opinion is the single most promising operating system ever written. Instead of being FHS compliant, NixOS keeps all files under hashed directory names under /nix/store so that files from different packages never have any collision. This allows the package manager to install multiple versions of the same packages, along with deterministic and atomic builds and upgrades.

Throwback
Now, I started using Nix a long time ago (~Sep 2015), often switching between Arch and Nix depending on my usage. Mostly I had to switch to Arch every time I couldn't figure out how to configure something in Nix (the methodologies, like the ideoligies are very different). About an year ago I switched to Nix full-time (i.e. no other operating system on dual boot). The reason being that I have learnt enough about the workings of Nix to make it do my day to day bidding without much effort.

Precursor
Every time I write a package for something, the installation procedure for Nix is quite different from other operating systems. While most operating systems would just ask you to compile and put the binary in /usr/bin, in Nix you aren't allowed to change the global state of the OS. This means that every package has to be accompanied by a config file that precisely lists all dependencies and the build environment needed by the package. How the OS provides that environment is none of our concern. If our package has a dependency, I need to only write that in my package's config file, and even without globally installing the package, my package would be able to build against the dependencies as well as use them during runtime. It is like a virtualenv except that it can be for any package, written in any language(s) and that has dependencies of any language(s). It's how virtualenv would look if it was 1000x smarter and more useful.

Since it simplifies development so much, I write my project's config file before even starting the project. When new dependencies or requirements emerge, it is a simple matter to modify a couple of lines in the config file. The best thing about this approach is that my packages are always testable, even if I reinstall the whole OS, I know that to run that package, I only need to run a shell with that config file. No more iteratively installing dependencies based on error messages.

Weren't we supposed to talk about CI?
Yes! Sorry.. I was building up to it. One of the major advantages of Nix is that Nix is a package manager that can be installed on other operating systems as well. Thus an existing Arch or Ubuntu or ... OS can actually benefit from a lot of this NIXey goodness by installing the Nix package manager. And very recently, struggling with getting the dependencies "just right" on Travis, I decided to exactly this.

Wait.. Travis?
(Skip this if you know about Travis CI)

Travis CI is a hosted, distributed continuous integration service used to build and test projects hosted at GitHub. Travis CI automatically detects when a commit has been made and pushed to a GitHub repository that is using Travis CI, and each time this happens, it will try to build the project and run tests. This includes commits to all branches, not just to the master branch. The point of this is that you can often discover very quickly if your commit broke something, and fix it before it becomes a problem.

And the problem was?
When writing a program, it is very easy to lose track of all its dependencies that you installed to get the code working, or the libraries it links against that are under a different name on your OS as compared to the OS running on the CI. At some point, everybody finds themselves battling with the package manager on the CI, iteratively running the tests again and again and fixing the next error that is reported on failure of the build.

I ran into this problem when I was trying to set up the CI for my blog's code. Yes, the website you are reading - that's what I am talking about. Since the final compiled product is a static website, I used to compile it on my PC and upload the compiled files for hosting. On my PC, the dependency management was just fine, because - you guessed it - I had written a Nix config file for it. Even so it was very hard to get it right on Travis, since it was running Ubuntu and my blog uses a rather lot of dependencies (jekyll, as well as python NLP libs for the search).

Solution!
Then I realised that I don't need to take this trouble. Nix always builds everything deterministically. Which means that if a build config file works fine on my laptop, it would work fine on Travis too. And since it is possible to install Nix on Ubuntu, I decided to see if it'd be able to use my existing config file to build my code using Nix instead.

The result was a small bunch of scripts that you can just curl directly from any build that uses a default.nix (Nix config file) for its builds and the Travis build would first install Nix and then complete the build using the Nix config file.

GitHub link for NixCI

Example
The above link would also be a good example of how to use the Nix CI from a project that uses Travis CI. Hint: look into the .travis.yml file. Note that you can directly curl the installation and configuration script from the above repository directly into your CI job. The link below is a fine example of how to do that.

To view an example of using this with GitLab CI: Click Here

Note that when sourcing from TravisCI, the script to run is install-nix.sh but from GitLab CI, the script to run is install-root.sh. The latter is a wrapper around the former but assumes that the user running the script is root and the wrapper (install-root.sh) creates a non-root user with sudo priviledges and runs the install-nix.sh script as the newly created user. This is not required in Travis since the default user in Travis is already a non-root user with sudo priviledges.
